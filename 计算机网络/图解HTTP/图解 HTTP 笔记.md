# 图解 HTTP 笔记

## 第一章 了解Web及网络基础

借助多文本之间相互关联形成的超文本（HyperText），连成可相互参阅的WWW(World Wide Web，万维网)。

通常用的网络（包括互联网）是在TCP/IP协议族的基础上运作的。而Http属于它内部的一个子集。



TCP/IP协议族：把与互联网相关联的协议集合起来总称为TCP/IP。一种说法：指TCP和IP这两种协议。另一种说法：在IP协议的通信过程中，使用到的协议族的统称。

分层：TCP/IP协议族按照层次分为：应用层、传输层、网络层、数据链路层。

- 应用层：决定了向用户提供应用服务时通信的活动。预存了各类通用的应用服务如FTP、DNS（Domain Name System，域名系统）、Http等。

- 传输层：传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。TCP、UDP
- 网络层：用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机。
- 数据链路层：用来处理连接网络的硬件部分。(物理层的功能：根据所使用的传输介质不同，制定不同的物理层协议，规定数据的编码方式，传输速率，相关的通信参数。数据链路层的功能：链路管理（数据链路的连接，维护与释放）、帧同步、流量控制、差错控制、透明传输、寻址)。



负责传输的IP（Internet Protocol，网际协议）协议：IP协议的作用是把各种数据包传送给对方。其中最重要的两个条件是IP地址和MAC地址（Media Access Control Address）。

使用ARP协议凭借MAC地址进行通信：ARP协议是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。

无论哪台计算机、哪台网络设备，他们都无法全面掌握互联网中的细节。

确保可靠通信的TCP协议：提供字节流服务，即 将大块数据分割成以报文段为单位的数据包进行管理。并且提供可靠的传输服务。

可靠传输：TCP三次握手：使用SYN（synchronize）和ACK（acknowledgement）。

![image-20210123153849970](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210123153849970.png)

负责域名解析的DNS服务：DNS位于应用层，提供域名到IP地址间的解析服务。

浏览器输入URL敲击回车后发生了什么：

![image-20210123155029519](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210123155029519.png)

统一资源标识符（URI）：某个协议方案表示的资源定位标识符。用字符串标识某一互联网资源，而URL标识资源的地点。**可见URL是URI的子集**。

URI格式：

![image-20210123161126585](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210123161126585.png)

可选：登录信息、端口号、查询字符串、片段标识符



## 第二章 简单的HTTP协议

在两台计算机之间使用 HTTP 协议通信时，在一条通信线路上必定有 一端是客户端，另一端则是服务器端。

**请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。**

![image-20210123162206454](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210123162206454.png)

**响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代 码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主 体构成。**

![image-20210123162452530](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210123162452530.png)

**HTTP 是一种不保存状态，即无状态（stateless）协议**。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。

HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于 是引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管 理状态了。

指定请求URI的方式：

![image-20210123163005230](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210123163005230.png)

- 告知服务器意图的HTTP方法：

**GET：**获取资源

**POST：**传输实体主体；POST 方法用来传输实体的主体。 虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行 传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但 POST 的主要目的并不是获取响应的主体内容。

**PUT：**传输文件；PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请 求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。 但是，鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以 上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。若 配合 Web 应用程序的验证机制，或架构设计采用REST（REpresentational State Transfer，表征状态转移）标准的同类 Web 网站，就可能会开放使用 PUT 方法。

**HEAD：**获得报文首部；HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。

**DELETE：**删除文件；但是，HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机 制，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用 程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的。

**OPTIONS：**询问支持的方法；OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。

**TRACE：**追踪路径；TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方 法。

**CONNECT：**要求使用隧道协议连接代理；CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协 议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接 层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容 加 密后经网络隧道传输。

方法名区分大 小写，注意要用大写字母。

![image-20210123164943939](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210123164943939.png)

持久连接节省通信量：HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。以当年的通信情况来说，因为都是些容量很小的文本传输，所以即使 这样也没有多大问题。可随着 HTTP 的普及，文档中包含大量图片的 情况多了起来。 比如，使用浏览器浏览一个包含多张图片的 HTML页面时，在发送 请求访问 HTML页面资源的同时，也会请求该 HTML页面里包含的 其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断 开，增加通信量的开销。

为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了 持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端 没有明确提出断开连接，则保持 TCP 连接状态。

**持久连接的好处**在于减少了 TCP 连接的重复建立和断开所造成的额 外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相 应提高了。

 **在 HTTP/1.1 中，所有的连接默认都是持久连接**，但在 HTTP/1.0 内并 未标准化。虽然有一部分服务器通过非标准的手段实现了持久连接， 但服务器端不一定能够支持持久连接。毫无疑问，除了服务器端，客 户端也需要支持持久连接。

管线化：持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从 前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术 出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。

- 使用Cookie的状态管理：

不可否认，**无状态协议当然也有它的优点**。由于不必保存状态，自然 可减少服务器的 CPU 及内存资源的消耗。从另一侧面来说，也正是 因为 HTTP 协议本身是非常简单的，所以才会被应用在各种场景里。

Cookie 技术通过在请求和响应报文中写入 Cookie 信 息来控制客户端的状态。 Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器 发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出 去。 服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一 个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前 的状态信息。

![image-20210123170407294](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210123170407294.png)

![image-20210123170421677](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210123170421677.png)

## 第三章 HTTP报文内的HTTP信息

HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。 

HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的 空行（CR+LF）来划分。通常，并不一定要有报文主体。

下请求报文和响应报文的结构：

![image-20210124122757958](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124122757958.png)

![image-20210124122811028](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124122811028.png)

请求行：包含用于请求的方法，请求 URI 和 HTTP 版本。 

状态行：包含表明响应结果的状态码，原因短语和 HTTP 版本。

首部字段：包含表示请求和响应的各种条件和属性的各类首部。 一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首部。 

其他：可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）。



编码提升传输速率：

HTTP 在传输数据时可以按照数据原貌直接传输，但也可以在传输过 程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量 的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多 的 CPU 等资源。

HTTP 报文的主体用于传输请求或响应的实体主体。 通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体 主体的内容发生变化，才导致它和报文主体产生差异。

内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。

在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前， 浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。 这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）。



发送多种数据的多部分对象集合：

HTTP 协议中也采纳了多部分对象集合，发送的一份报文主 体内可含有多类型实体。通常是在图片或文本文件等上传时使用。

在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上 Content-type。

使用 boundary 字符串来划分多部分对象集合指明的各类实体。在 boundary 字符串指定的各个实体的起始行之前插入“--”标记，而在多部分对象集合对 应的字符串的最后插入“--”标记作为结束。 多部分对象集合的每个部分类型中，都可以含有首部字段。另外，可 以在某个部分中嵌套使用多部分对象集合。



获取部分内容的范围请求：

如果下载过程中遇到网络 中断的情况，那就必须重头开始。为了解决上述问题，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。 要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请 求叫做**范围请求（Range Request）**。

![image-20210124124830959](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124124830959.png)

执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。 byte 范围的指定形式如下：

![image-20210124124816834](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124124816834.png)

针对范围请求，响应会返回状态码为 206 Partial Content 的响应报 文。另外，对于多重范围的范围请求，响应会在首部字段 ContentType 标明 multipart/byteranges 后返回响应报文。如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的 实体内容。



内容协商返回最合适的内容：

当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时， 则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容 协商（Content Negotiation）。

内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然 后提供给客户端最为适合的资源。

内容协商会以响应资源的语言、字 符集、编码方式等作为判断的基准。 包含在请求报文中的某些首部字段（如下）就是判断的基准：

- Accept
- Accept-Charset
- Accept-Encoding
- Accept-Language
- Content-Language

内容协商技术有以下 3 种类型：

- 服务器驱动协商（Server-driven Negotiation）
- 客户端驱动协商（Agent-driven Negotiation）
- 透明协商（Transparent Negotiation）



## 第四章 返回结果的HTTP状态码

状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出 现了错误。

状态码如 200 OK，以 3 位数字和原因短语组成。

 数字中的第一位指定了响应类别，后两位无分类。响应类别有以下 5 种：

![image-20210124130143697](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124130143697.png)

状态码共60余种，常用的14种：

- 200 OK：表示从客户端发来的请求在服务器端被正常处理了。
- 204 No Content：该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中 不含实体的主体部分。另外，也不允许返回任何实体的主体。一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。
- 206 Partial Content：该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。



- 301 Moved Permanently：永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后 应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。

- 302 Found：临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望 用户（本次）能使用新的 URI 访问。

- 303 See Other：

  该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。 303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确 表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区 别。

  比如，当使用 POST 方法访问 CGI 程序，其执行后的处理结果是希望 客户端能以 GET 方法重定向到另一个 URI 上去时，返回 303 状态 码。虽然 302 Found 状态码也可以实现相同的功能，但这里使用 303 状态码是最理想的。

- 304 Not Modified：该状态码表示客户端发送附带条件的请求 2 时，服务器端允许请求访 问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应 的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关 系。
- 307 Temporary Redirect：临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。 307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响 应时的行为，每种浏览器有可能出现不同的情况。
- 400 Bad Request：该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求 的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。（？）
- 401 Unauthorized：该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、 DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示 用 户认证失败。 返回含有 401 的响应必须包含一个适用于被请求资源的 WWWAuthenticate 首部用以质询（challenge）用户信息。当浏览器初次接收 到 401 响应，会弹出认证用的对话窗口。
- 403 Forbidden：该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要 给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。
- 404 Not Found：该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服 务器端拒绝请求且不想说明理由时使用。
- 500 Internal Server Error：该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。
- 503 Service Unavailable：该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法 处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。



## 第五章 与HTTP协作的Web服务器

HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。比如，提 供 Web 托管服务（Web Hosting Service）的供应商，可以用一台服务 器为多位客户服务，也可以以每位客户持有的域名运行各自不同的网 站。这是因为利用了虚拟主机（Virtual Host，又称虚拟服务器）的功 能。 即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以 假想已具有多台服务器。

在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名 的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指 定主机名或域名的 URI。



HTTP 通信时，除客户端和服务器以外，还有一些用于通信数据转发 的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。 这些应用程序和服务器可以将请求转发给通信线路上的下一站服务 器，并且能接收从那台服务器发送的响应再转发给客户端。

- 代理：代理是一种有转发功能的应用程序，它扮演了位于服务器和客户 端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时 也接收服务器返回的响应并转发给客户端。

![image-20210124143728984](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124143728984.png)

在 HTTP 通信过程中，可级联多台代理服务器。请求和响应的转发会 经过数台类似锁链一样连接起来的代理服务器。转发时，需要附加 Via 首部字段以标记出经过的主机信息。

使用代理服务器的理由有：利用缓存技术（稍后讲解）减少网络带宽 的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要 目的，等等。 代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一 种是是否会修改报文。

缓存代理：代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本 （缓存）保存在代理服务器上。 当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获 取资源，而是将之前缓存的资源作为响应返回。

透明代理：转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理 （Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。

- 网关：网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请 求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客 户端可能都不会察觉，自己的通信目标是一个网关。

![image-20210124144140209](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124144140209.png)

网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提 供非 HTTP 协议服务。 利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信 线路上加密以确保连接的安全。

- 隧道：隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方 通信连接的应用程序。

![image-20210124144244238](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124144244238.png)

隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL等 加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的 通信。 隧道本身不会去解析 HTTP 请求。也就是说，请求保持原样中转给之 后的服务器。隧道会在通信双方断开连接时结束。



保存资源的缓存：缓存是指**代理服务器或客户端本地磁盘**内保存的资源副本。利用缓存 可减少对源服务器的访问，因此也就节省了通信流量和通信时间。 缓存服务器是代理服务器的一种，并归类在缓存代理类型中。换句话 说，当代理转发从服务器返回的响应时，代理服务器将会保存一份资 源的副本。

![image-20210124144448212](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124144448212.png)

缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因 此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处 理相同的请求了。



## 第六章 HTTP首部

HTTP请求报文：

![image-20210124145214154](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124145214154.png)

HTTP响应报文：

![image-20210124145314191](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124145314191.png)

HTTP首部字段：

HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“:” 分 隔。

单个 HTTP 首部字段可以有多个值：

![image-20210124145816376](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124145816376.png)

HTTP 首部字段根据实际用途被分为以下 4 种类型：

- 通用首部字段（General Header Fields）：请求报文和响应报文两方都会使用的首部。
- 请求首部字段（Request Header Fields）：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。
- 响应首部字段（Response Header Fields）：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。
- 实体首部字段（Entity Header Fields）：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等**与实体有关**的信息。

HTTP/1.1 首部字段一览：

![image-20210124150623164](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124150623164.png)

![image-20210124150639750](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124150639750.png)

![image-20210124150653192](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124150653192.png)

![image-20210124150703417](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124150703417.png)

HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分成 2 种类型：

- 端到端首部（End-to-end Header） 分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。
- 逐跳首部（Hop-by-hop Header） 分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。 

下面列举了 HTTP/1.1 中的逐跳首部字段。除这 8 个首部字段之外， 其他所有字段都属于端到端首部：

- Connection
- Keep-Alive
- Proxy-Authenticate
- Proxy-Authorization
- Trailer
- TE
- Transfer-Encoding
- Upgrade



**HTTP/1.1 通用首部字段：**

- Cache-Control：能操作缓存的工作机 制。

指令的参数是可选的，多个指令之间通过“,”分隔。![image-20210124151418394](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124151418394.png)

![image-20210124151805398](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124151805398.png)

表示是否能缓存的指令：

public 指令，当指定使用 public 指令时，则明确表明其他用户也可利用缓存。

private 指令，当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。 缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送 过来的请求，代理服务器则不会返回缓存。

no-cache 指令，使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。 客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接 收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发 给源服务器。 如果服务器返回的响应中包含 no-cache 指令，那么缓存服务器不能对 资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资 源有效性进行确认，且禁止其对响应资源进行缓存操作。

由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache 字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首 部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首 部字段可以使用缓存。只能在响应指令中指定该参数。



控制可执行缓存的对象的指令：

no-store 指令：当使用 no-store 指令时，暗示请求（和对应的响应）或响应中包含 机密信息。因此，该指令规定缓存不能在本地存储请求或响应的任一部分。

 **从字面意思上很容易把 no-cache 误解成为不缓存，但事实上 no-cache 代表不缓 存过期的资源，缓存会向源服务器进行有效期确认后处理资源，也许称为 do-notserve-from-cache-without-revalidation 更合适。no-store 才是真正地不进行缓存。**



指定缓存期限和认证的指令：

s-maxage 指令：s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 smaxage 指令只适用于供多位用户使用的公共缓存服务器（代理）。也就是 说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。另外，当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及 max-age 指令的处理。

max-age 指令：当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓 存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。 另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发 给源服务器。 当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源 的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。

![image-20210124153137348](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124153137348.png)

应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情 况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而 HTTP/1.0 版本的缓存服务器的情况却相反，max-age 指令会被忽略掉。

min-fresh 指令：min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。比如，当指定 min-fresh 为 60 秒后，过了 60 秒的资源都无法作为响 应返回了。

![image-20210124153433292](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124153433292.png)

max-stale 指令：使用 max-stale 可指示缓存资源，即使过期也照常接收。 如果指令未指定参数值，那么无论经过多久，客户端都会接收响应； 如果指令中指定了具体数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收。

only-if-cached 指令：使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资 源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新 加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本 地缓存无响应，则返回状态码 504 Gateway Timeout。

must-revalidate 指令：使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响 应缓存目前是否仍然有效。 若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端 一条 504（Gateway Timeout）状态码。 另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已 经在首部使用了 max-stale，也不会再有效果）。

proxy-revalidate 指令：proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指 令的请求返回响应之前，必须再次验证缓存的有效性。

no-transform 指令：使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改 变实体主体的媒体类型。 这样做可防止缓存或代理压缩图片等类似操作。

Cache-Control 扩展：

cache-extension token：

![image-20210124160407682](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124160407682.png)

通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字 段内的指令。 如上例，Cache-Control 首部字段本身没有 community 这个指令。借助 extension tokens 实现了该指令的添加。如果缓存服务器不能理解 community 这个新指令，就会直接忽略。因此，extension tokens 仅对 能理解它的缓存服务器来说是有意义的。



- Connection：Connection 首部字段具备如下两个作用：

- - 控制不再转发给代理的首部字段：在客户端发送请求和服务器返回响应内，使用 Connection 首部字 段，可控制不再转发给代理的首部字段（即 Hop-by-hop 首 部）。

    ![image-20210124160701336](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124160701336.png)

  - 管理持久连接：HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持 久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为 此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。如下图①所示，客户端发送请求给服务器时，服务器端会像上图 ②那样加上首部字段 Keep-Alive 及首部字段 Connection 后返回 响应。

    ![image-20210124160844055](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124160844055.png)

    ![image-20210124160930300](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124160930300.png)

    

- Date：首部字段 Date 表明创建 HTTP 报文的日期和时间。

三种格式：

![image-20210124161318317](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124161318317.png)

- Pragma：Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。

![image-20210124161515347](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124161515347.png)

该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户 端会要求所有的中间服务器不返回缓存的资源。所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 CacheControl: no-cache 指定缓存的处理方式是最为理想的。但要整体掌握 全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的 请求会同时含有下面两个首部字段。

![image-20210124161545017](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124161545017.png)

- Trailer：首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该 首部字段可应用在 HTTP/1.1 版本分块传输编码时。

  ![image-20210124161710172](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124161710172.png)

  ![image-20210124161719228](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124161719228.png)

- Transfer-Encoding：Transfer-Encoding 规定了传输报文主体时采用的编码方式。 HTTP/1.1 的传输编码方式仅对分块传输编码有效。（报文的传输方式，如分块）

  ![image-20210124162025028](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124162025028.png)

- Upgrade：首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的 版本进行通信，其参数值可以用来指定一个完全不同的通信协议。

![image-20210124162502601](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124162502601.png)

上图用例中，首部字段 Upgrade 指定的值为 TLS/1.0。请注意此处两 个字段首部字段的对应关系，Connection 的值被指定为 Upgrade。 Upgrade 首部字段产生作用的 Upgrade 对象仅限于客户端和邻接服务 器之间。因此，使用首部字段 Upgrade 时，还需要额外指定 Connection:Upgrade。 对于附有首部字段 Upgrade 的请求，服务器可用 101 Switching Protocols 状态码作为响应返回。

- Via：使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文 的传输路径。 报文经过代理或网关时，会先在首部字段 Via 中附加该服务器的信 息，然后再进行转发。首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。 所以必须在经过代理时附加该首部字段内容。

![image-20210124163325961](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124163325961.png)

上图用例中，在经过代理服务器 A 时，Via 首部附加了“1.0 gw.hackr.jp (Squid/3.1)”这样的字符串值。行头的 1.0 是指接收请求的服务器上应用的 HTTP 协议版本。

Via 首部是为了追踪传输路径，所以经常会和 TRACE 方法一起使 用。

- Warning：该首部通常会告知用户一些与缓存相关的问题的警告。

Warning 首部的格式如下。最后的日期时间部分可省略。

![image-20210124163634177](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124163634177.png)

HTTP/1.1 中定义了 7 种警告。警告码对应的警告内容仅推荐参考。 另外，警告码具备扩展性，今后有可能追加新的警告码：

![image-20210124163657007](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124163657007.png)

**请求首部字段：**

请求首部字段是从客户端往服务器端发送请求报文中所使用的字段， 用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等 内容。

- Accept：Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体 类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。

若想要给显示的媒体类型增加优先级，则使用 q= 来额外表示权重值，用分号（;）进行分隔。权重值 q 的范围是 0~1（可精确到小数点 后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。

当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。

- Accept-Charset：Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及 字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字 段 Accept 相同的是可用权重 q 值来表示相对优先级。 该首部字段应用于内容协商机制的服务器驱动协商。

- Accept-Encoding：Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及 内容编码的优先级顺序。可一次性指定多种内容编码。采用权重 q 值来表示相对优先级，这点与首部字段 Accept 相同。另 外，也可使用星号（*）作为通配符，指定任意的编码格式。
- Accept-Language：首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然 语言集（指中文或英文等），以及自然语言集的相对优先级。可一次 指定多种自然语言集。 和 Accept 首部字段一样，按权重值 q 来表示相对优先级。在上述图 例中，客户端在服务器有中文版资源的情况下，会请求其返回中文版 对应的响应，没有中文版时，则请求返回英文版响应。
- Authorization：首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证 书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存 在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。
- Expect：客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行 为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回 状态码 417 Expectation Failed。 客户端可以利用该首部字段，写明所期望的扩展。虽然 HTTP/1.1 规 范只定义了 100-continue（状态码 100 Continue 之意）。 等待状态码 100 响应的客户端在发生请求时，需要指定 Expect:100- continue。
- From：首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地 址。通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的 电子邮件联系方式。使用代理时，应尽可能包含 From 首部字段（但 可能会因代理不同，将电子邮件地址记录在 User-Agent 首部字段内）。
- Host：首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端 口号。**Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段**。首部字段 Host 和以单台服务器分配多个域名的虚拟主机的工作机制 有很密切的关联，这是首部字段 Host 必须存在的意义。若服务器未设定主机名，那直 接发送一个空值即可。

![image-20210124165150054](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124165150054.png)

- If-Match：形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接 收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用 的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致 时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响 应。 还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务 器将会忽略 ETag 的值，只要资源存在就处理请求。

  ![image-20210124165618908](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124165618908.png)

- If-Modified-Since：首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 IfModified-Since 字段值早于资源的更新时间，则希望能处理该请求。 而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源 都没有过更新，则返回状态码 304 Not Modified 的响应。 If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。 获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确 定。

  ![image-20210124165835751](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124165835751.png)

- If-None-Match：首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与 请求资源的 ETag 不一致时，它就告知服务器处理该请求。 在 GET 或 HEAD 方法中使用首部字段 If-None-Match 可获取最新的资 源。因此，这与使用首部字段 If-Modified-Since 时有些类似。

  ![image-20210124170013881](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124170013881.png)

- If-Range：首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 IfRange 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一 致时，则作为范围请求处理。反之，则返回全体资源。

![image-20210124170220957](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124170220957.png)

- If-Unmodified-Since：首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相 反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定 的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定 日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应 返回。
- Max-Forwards：通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 MaxForwards 的请求时，该字段以十进制整数形式指定可经过的服务器最 大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的 值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求 时，则不再进行转发，而是直接返回响应。 使用 HTTP 协议通信时，请求可能会经过代理等多台服务器。途中， 如果代理服务器由于某些原因导致请求转发失败，客户端也就等不到 服务器返回的响应了。对此，我们无从可知。

![image-20210124170438314](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124170438314.png)

- Proxy-Authorization：接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同 之处在于，认证行为发生在客户端与代理之间。客户端与服务器之间 的认证，使用首部字段 Authorization 可起到相同作用。
- Range：对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服 务器资源的指定范围。接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状 态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返 回状态码 200 OK 的响应及全部资源。
- Referer：客户端一般都会发送 Referer 首部字段给服务器。但当直接在浏览器 的地址栏输入 URI，或出于安全性的考虑时，也可以不发送该首部字 段。 因为原始资源的 URI 中的查询字符串可能含有 ID 和密码等保密信 息，要是写进 Referer 转发给其他服务器，则有可能导致保密信息的泄露。
- TE：首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相 对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于 传输编码。 首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分 块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。
- User-Agent：首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传 达给服务器。 由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件 地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服 务器的名称。



**响应首部字段：**

响应首部字段是由服务器端向客户端返回响应报文中所使用的字段， 用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等 信息。

- Accept-Ranges：首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请 求，以指定获取服务器端某个部分的资源。 可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则 指定其为 none。
- Age：首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值 的单位为秒。 若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次 发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。（？）

![image-20210124171815893](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124171815893.png)

- ETag：首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串 形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有 统一的算法规则，而仅仅是由服务器来分配。资源被缓存时，就会被分配唯一性标识。例如，当使用中文版的浏览 器访问 http://www.google.com/ 时，就会返回中文版对应的资源，而 使用英文版的浏览器访问时，则会返回英文版对应的资源。两者的 URI 是相同的，所以仅凭 URI 指定缓存的资源是相当困难的。若在下 载过程中出现连接中断、再连接的情况，都会依照 ETag 值来指定资源。

  强 ETag 值 强 ETag 值，不论实体发生多么细微的变化都会改变其值。

  弱 ETag 值 弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产 生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/。

  ![image-20210124172146788](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124172146788.png)

- Location：使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置 不同的资源。 基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。 几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强 制性地尝试对已提示的重定向资源的访问。

![image-20210124172517485](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124172517485.png)

- Proxy-Authenticate：首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送 给客户端。 它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在 于其认证行为是在客户端与代理之间进行的。而客户端与服务器之间 进行认证时，首部字段 WWW-Authorization 有着相同的作用。
- Retry-After：首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要 配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使 用。 字段值可以指定为具体的日期时间（Wed, 04 Jul 2012 06：34：24 GMT 等格式），也可以是创建响应后的秒数。
- Server：首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程 序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版 本号和安装时启用的可选项。
- Vary：首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关 于本地缓存使用方法的命令。 从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若 再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回 缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相 同，因此必须要从源服务器重新获取资源。

![image-20210124173554258](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124173554258.png)

- WWW-Authenticate：首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端 适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和 带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中， 肯定带有首部字段 WWW-Authenticate。realm 字段的字符串是为了辨别请求 URI 指定资源所受 到的保护策略。

**实体首部字段：**

- Allow：首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所 有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支 持的 HTTP 方法写入首部字段 Allow 后返回。
- Content-Encoding：首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选 用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行 的压缩。
- Content-Language：首部字段 Content-Language 会告知客户端，实体主体使用的自然语言 （指中文或英文等语言）。
- Content-Length：首部字段 Content-Length 表明了实体主体部分的大小（单位是字 节）。对实体主体进行内容编码传输时，不能再使用 Content-Length 首部字段。
- Content-Location：首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首 部字段 Location 不同，Content-Location 表示的是报文主体返回资源对 应的 URI。
- Content-MD5：首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检 查报文主体在传输过程中是否保持完整，以及确认传输到达。为确保报文的有效性，作为接 收方的客户端会对报文主体再执行一次相同的 MD5 算法。计算出的值与字段值作比较后，即可判断出报文主体的准确性。采用这种方法，对内容上的偶发性改变是无从查证的，也无法检测出 恶意篡改。其中一个原因在于，内容如果能够被篡改，那么同时意味 着 Content-MD5 也可重新计算然后被篡改。所以处在接收阶段的客户 端是无法意识到报文主体以及首部字段 Content-MD5 是已经被篡改过 的。
- Content-Range：针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客 户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为 单位，表示当前发送部分及整个实体大小。
- Content-Type：首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字 段 Accept 一样，字段值用 type/subtype 形式赋值。 参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值。
- Expires：首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接 收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过 指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求 资源。 源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写 入与首部字段 Date 相同的时间值。 但是，当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字 段 Expires，会优先处理 max-age 指令。
- Last-Modified：首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个 值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进 行动态数据处理时，该值有可能会变成数据最终修改时的时间。



**为 Cookie 服务的首部字段：**

Cookie 的工作机制是用户识别及状态管理。Web 网站为了管理用户的 状态会通过 Web 浏览器，把一些数据临时写入用户的计算机内。接 着当用户访问该Web网站时，可通过通信方式取回之前发放的 Cookie。 调用 Cookie 时，由于可校验 Cookie 的有效期，以及发送方的域、路 径、协议等信息，所以正规发布的 Cookie 内的数据不会因来自其他 Web 站点和攻击者的攻击而泄露。

![image-20210124175609444](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124175609444.png)

- Set-Cookie：当服务器准备开始管理客户端的状态时，会事先告知各种信息。

下面的表格列举了 Set-Cookie 的字段值。：

![image-20210124175906058](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124175906058.png)

expires 属性：Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。 当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session） 时间段内。这通常限于浏览器应用程序被关闭之前。 另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可 以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对 客户端 Cookie 的实质性删除操作。

path 属性：Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。 不过另有办法可避开这项限制，看来对其作为安全机制的效果不能抱有期待。 

domain 属性：通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比 如，当指定 example.com 后，除 example.com 以外，www.example.com 或 www2.example.com 等都可以发送 Cookie。 因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定 domain 属性显得更安全。 

secure 属性：Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才 可以发送 Cookie。当省略 secure 属性时，不论 HTTP 还是 HTTPS，都会对 Cookie 进行 回收。

HttpOnly 属性：Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本 无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作。 但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后 的 Cookie 的内容了。因此，也就无法在 XSS 中利用 JavaScript 劫持 Cookie 了。



- Cookie：首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支 持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。



**其他首部字段：**

HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应 用上，会出现各种非标准的首部字段。

- X-Frame-Options
- X-XSS-Protection
- DNT
- P3P



## 第七章 确保 Web 安全的 HTTPS

HTTP缺点：

- 通信使用明文（不加密），内容可能会被窃听
- 不验证通信方的身份，因此有可能遭遇伪装
- 无法证明报文的完整性，所以有可能已遭篡改

加密可分两种：

对通信的加密：HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全层传输协议）的组合使用， 加密 HTTP 的通信内容。 用 SSL建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。与 SSL组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）。

对内容的加密： 还有一种将参与通信的内容本身加密的方式。由于 HTTP 协议中 没有加密机制，那么就对 HTTP 协议传输的内容本身加密。即把 HTTP 报文里所含的内容进行加密处理。诚然，为了做到有效的内容加密，前提是要求客户端和服务器同 时具备加密和解密机制。主要应用在 Web 服务中。有一点必须 引起注意，由于该方式不同于 SSL或 TLS 将整个通信线路加密 处理，所以内容仍有被篡改的风险。

不确认通信方存在的各种隐患：

- 无法确定请求发送至目标的 Web 服务器是否是按真实意 图返回响应的那台服务器。有可能是已伪装的 Web 服务器。
-  无法确定响应返回到的客户端是否是按真实意图接收响 应的那个客户端。有可能是已伪装的客户端。
- 无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器上保存着重要的信息，只想发给特定用户通 信的权限。
- 无法判定请求是来自何方、出自谁手。
- 即使是无意义的请求也会照单全收。无法阻止海量请求 下的 DoS 攻击（Denial of Service，拒绝服务攻击）。



查明对手的证书：虽然使用 HTTP 协议无法确定通信方，但如果使用 SSL则可以。 SSL不仅提供加密处理，而且还使用了一种被称为证书的手段， 可用于确定方。 证书由值得信任的第三方机构颁发，用以证明服务器和客户端是 实际存在的。另外，伪造证书从技术角度来说是异常困难的一件 事。所以只要能够确认通信方（服务器或客户端）持有的证书， 即可判断通信方的真实意图。



请求或响应在传输途中，遭攻击者拦截并篡改内容的攻 击称为中间人攻击（Man-in-the-Middle attack，MITM）。

SSL提供认证和加 密处理及摘要功能。仅靠 HTTP 确保完整性是非常困难的，因此 通过和其他协议组合使用来实现这个目标。



**HTTP+ 加密 + 认证 + 完整性保护 =HTTPS**

经常会在 Web 的登录页面和购物结算界面等使用 HTTPS 通信。使用 HTTPS 通信时，不再用 http://，而是改用 https://。另外，当浏览器访 问 HTTPS 通信有效的 Web 网站时，浏览器的地址栏内会出现一个带 锁的标记。对 HTTPS 的显示方式会因浏览器的不同而有所改变。

HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代 替而已。 通常，HTTP 直接和 TCP 通信。当使用 SSL时，则演变成先和 SSL通 信，再由 SSL和 TCP 通信了。在采用 SSL后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护 这些功能。

![image-20210124183912422](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124183912422.png)

SSL是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应 用层的 SMTP 和 Telnet 等协议均可配合 SSL协议使用。可以说 SSL是 当今世界上应用最为广泛的网络安全技术。

SSL采用一种 叫做公开密钥加密（Public-key cryptography）的加密处理方式。 近代的加密方法中加密算法是公开的，而密钥却是保密的。通过这种 方式得以保持加密方法的安全性。 加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说， 任何人只要持有密钥就能解密了。如果密钥被攻击者获得，那加密也 就失去了意义。

加密和解密同用一个密钥的方式称为共享密钥加密（Common key crypto system），也被叫做对称密钥加密。

![image-20210124184245132](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124184245132.png)

公开密钥加密方式很好地解决了共享密钥加密的困难：公开密钥加密使用一对非对称的密钥。一把叫做私有密钥 （private key），另一把叫做公开密钥（public key）。顾名思 义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发 布，任何人都可以获得。 使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进 行加密处理，对方收到被加密的信息后，再使用自己的私有密钥 进行解密。利用这种方式，不需要发送用来解密的私有密钥，也 不必担心密钥被攻击者窃听而盗走。 另外，要想根据密文和公开密钥，恢复到信息原文是异常困难 的，因为解密过程就是在对离散对数进行求值，这并非轻而易举 就能办到。退一步讲，如果能对一个非常大的整数做到快速地因 式分解，那么密码破解还是存在希望的。但就目前的技术来看是 不太现实的。

![image-20210124184511124](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124184511124.png)

HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。 所以应充分利用两者各自的优势，将多种方法组合起来用于通 信。**在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。**

公开密钥加密方式还是存在一些问题的。那就是无法证明 公开密钥本身就是货真价实的公开密钥。比如，正准备和某台服务器 建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原 本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真 正的公开密钥已经被攻击者替换掉了。 为了解决上述问题，可以使用由**数字证书认证机构**（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。

数字证书认证机构的业务流程：首先，服务器 的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证 机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签 名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书 后绑定在一起。

服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书。 接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书 上的数字签名进行验证，一旦验证通过，客户端便可明确两件事： 一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二， 服务器的公开密钥是值得信赖的。

HTTPS通信步骤：

![image-20210124212854726](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124212854726.png)

详见P162.

HTTPS 也存在一些问题，那就是当使用 SSL时，它的处理速度会**变慢**。

SSL的慢分两种。一种是指通信慢。另一种是指由于大量消耗 CPU 及内存等资源，导致处理速度变慢。 和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和 TCP 连接、发送 HTTP 请求 • 响应以外，还必须进行 SSL通信， 因此整体上处理通信量不可避免会增加。

 另一点是 SSL必须进行加密处理。在服务器和客户端都需要进行 加密和解密的运算处理。因此从结果上讲，比起 HTTP 会更多地 消耗服务器和客户端的硬件资源，导致负载增强。



## 第八章 确认访问用户身份的认证

HTTP/1.1 使用的认证方式如下：

- BASIC 认证（基本认证） 
- DIGEST 认证（摘要认证） 
- SSL 客户端认证 
- FormBase 认证（基于表单认证）



BASIC 认证（基本认证） ：

![image-20210124213914075](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124213914075.png)

DIGEST 认证：

![image-20210124214617245](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124214617245.png)

SSL 客户端认证：

SSL 客户端认证的认证步骤：

为达到 SSL客户端认证的目的，需要事先将客户端证书分发给客户 端，且客户端必须安装此证书。

 步骤 1： 接收到需要认证资源的请求，服务器会发送 Certificate Request 报文，要求客户端提供客户端证书。 

步骤 2： 用户选择将发送的客户端证书后，客户端会把客户端证书信 息以 Client Certificate 报文方式发送给服务器。

步骤 3： 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。

在多数情况下，SSL客户端认证不会仅依靠证书完成认证，一般会和 基于表单认证（稍后讲解）组合形成一种双因素认证（Two-factor authentication）来使用。所谓双因素认证就是指，认证过程中不仅需 要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为 另一个因素，与其组合使用的认证方式。 换言之，第一个认证因素的 SSL客户端证书用来认证客户端计算机， 另一个认证因素的密码则用来确定这是用户本人的行为。 通过双因素认证后，就可以确认是用户本人正在使用匹配正确的计算 机访问服务器。



基于表单认证：

基于表单的认证方法并不是在 HTTP 协议中定义的。客户端会向服务 器上的 Web 应用程序发送登录信息（Credential），按登录信息的验 证结果认证。

Session 管理及 Cookie 应用：一般会使用 Cookie 来管理 Session（会话）。 基于表单认证本身是通过服务器端的 Web 应用，将客户端发送过来 的用户 ID 和密码与之前登录过的信息做匹配来进行认证的。 但鉴于 HTTP 是无状态协议，之前已认证成功的用户状态无法通过协 议层面保存下来。即，无法实现状态管理，因此即使当该用户下一次 继续访问，也无法区分他与其他的用户。于是我们会使用 Cookie 来 管理 Session，以弥补 HTTP 协议中不存在的状态管理功能。

![image-20210124215909204](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124215909204.png)

步骤 1： 客户端把用户 ID 和密码等登录信息放入报文的实体部分， 通常是以 POST 方法把请求发送给服务器。而这时，会使用 HTTPS 通信来进行 HTML表单画面的显示和用户输入数据的发送。 

步骤 2： 服务器会发放用以识别用户的 Session ID。通过验证从客户 端发送过来的登录信息进行身份认证，然后把用户的认证状态与 Session ID 绑定后记录在服务器端。 向客户端返回响应时，会在首部字段 Set-Cookie 内写入 Session ID（如 PHPSESSID=028a8c…）。 你可以把 Session ID 想象成一种用以区分不同用户的等位号。然而，如果 Session ID 被第三方盗走，对方就可以伪装成你的身份进 行恶意操作了。因此必须防止 Session ID 被盗，或被猜出。为了做到 这点，Session ID 应使用难以推测的字符串，且服务器端也需要进行 有效期的管理，保证其安全性。 另外，为减轻跨站脚本攻击（XSS）造成的损失，建议事先在 Cookie 内加上 httponly 属性。 

步骤 3： 客户端接收到从服务器端发来的 Session ID 后，会将其作为 Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送 Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证 接收到的 Session ID 识别用户和其认证状态。



## 第九章 基于 HTTP 的功能追加协议

HTTP 瓶颈：

-  一条连接上只可发送一个请求。 
- 请求只能从客户端开始。客户端不可以接收除响应以外的指 令。 
- 请求 / 响应首部未经压缩就发送。首部信息越多延迟越大。 
- 发送冗长的首部。每次互相发送相同的首部造成的浪费较 多。
- 可任意选择数据压缩格式。非强制压缩发送。



**SPDY：**

Google 在 2010 年发布了 SPDY（取自 SPeeDY，发音同 speedy），其 开发目标旨在解决 HTTP 的性能瓶颈，缩短 Web 页面的加载时间 （50%）。

为了进 行根本性的改善，需要有一些协议层面上的改动。 处于持续开发状态中的 SPDY 协议，正是为了在协议级别消除 HTTP 所遭遇的瓶颈。

使用 SPDY 后，HTTP 协议额外获得以下功能：

- 多路复用流：通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。所有请求 的处理都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高。 
- 赋予请求优先级：SPDY 不仅可以无限制地并发处理请求，还可以给请求逐个分配优先 级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响 应变慢的问题。 
- 压缩 HTTP 首部：压缩 HTTP 请求和响应的首部。这样一来，通信产生的数据包数量和 发送的字节数就更少了。 
- 推送功能：支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送 数据，而不必等待客户端的请求。
- 服务器提示功能：服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源 之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。



**使用浏览器进行全双工通信的 WebSocket：**

由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端， 而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方 都可直接向对方发送报文。

主要特点：

-  推送功能：支持由服务器向客户端推送数据的推送功能。这样，服务器可直接发 送数据，而不必等待客户端的请求。 
- 减少通信量：只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相 比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息 很小，通信量也相应减少了。

![image-20210124221847498](%E5%9B%BE%E8%A7%A3%20HTTP%20%E7%AC%94%E8%AE%B0.assets/image-20210124221847498.png)



**期盼已久的 HTTP/2.0**

**Web 服务器管理文件的 WebDAV**



## 第十章 构建 Web 内容的技术

**HTML：**

HTML（HyperText Markup Language，超文本标记语言）是为了发送 Web 上的超文本（Hypertext）而开发的标记语言。超文本是一种文档 系统，可将文档中任意位置的信息与其他信息（文本或图片等）建立 关联，即超链接文本。标记语言是指通过在文档的某部分穿插特别的 字符串标签，用来修饰文档的语言。我们把出现在 HTML文档内的 这种特殊字符串叫做 HTML标签（Tag）。 平时我们浏览的 Web 页面几乎全是使用 HTML写成的。由 HTML构 成的文档经过浏览器的解析、渲染后，呈现出来的结果就是 Web 页面。

CSS（Cascading Style Sheets，层叠样式表）可以指定如何展现 HTML 内的各种元素，属于样式表标准之一。即使是相同的 HTML文档， 通过改变应用的 CSS，用浏览器看到的页面外观也会随之改变。CSS 的理念就是让文档的结构和设计分离，达到解耦的目的。



**动态 HTML：**

动态 HTML技术是通过调用客户端脚本语言 JavaScript，实现对 HTML的 Web 页面的动态改造。利用 DOM（Document Object Model，文档对象模型）可指定欲发生动态变化的 HTML元素。

DOM 是用以操作 HTML文档和 XML文档的 API（Application Programming Interface，应用编程接口）。使用 DOM 可以将 HTML内 的元素当作对象操作，如取出元素内的字符串、改变那个 CSS 的属 性等，使页面的设计发生改变。 通过调用 JavaScript 等脚本语言对 DOM 的操作，可以以更为简单的 方式控制 HTML的改变。



**Web 应用：**

Servlet是一种能在服务器上创建动态内容的程序。Servlet 是用 Java 语言实现的一个接口，属于面向企业级 Java（JavaEE，Java Enterprise Edition）的一部分。



**数据发布的格式及语言：**

XML（eXtensible Markup Language，可扩展标记语言）是一种可按应 用目标进行扩展的通用标记语言。旨在通过使用 XML，使互联网数 据共享变得更容易。

XML和 HTML一样，使用标签构成树形结构，并且可自定义扩展标 签。 从 XML文档中读取数据比起 HTML更为简单。由于 XML的结构基 本上都是用标签分割而成的树形结构，因此通过语法分析器 （Parser）的解析功能解析 XML结构并取出数据元素，可更容易地对 数据进行读取。 更容易地复用数据使得 XML在互联网上被广泛接受。比如，可用在 2 个不同的应用之间的交换数据格式化。

JSON（JavaScript Object Notation）是一种以 JavaScript（ECMAScript）的对象表示法为基础的轻量级数据标记语 言。能够处理的数据类型有 false/null/true/ 对象 / 数组 / 数字 / 字符 串，这 7 种类型。JSON 让数据更轻更纯粹，并且 JSON 的字符串形式可被 JavaScript 轻易地读入。当初配合 XML使用的 Ajax 技术也让 JSON 的应用变得 更为广泛。另外，其他各种编程语言也提供丰富的库类，以达到轻便 操作 JSON 的目的。