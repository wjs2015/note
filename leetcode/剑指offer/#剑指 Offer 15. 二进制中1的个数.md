# #[剑指 Offer 15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

## 示例 1：

```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

## 示例 2：

```
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```

## 示例 3：

```
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```

## 提示：

- 输入必须是长度为 `32` 的 **二进制串** 。



## 解题思路：

### 解 1：循环遍历每一位

输入 n 与 1 做位与，结果是1则结果加1，每次循环都将 n 右移一位（>>>）。

~~~java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int res = 0;
        while (n!=0) {
            res += n&1;
            n >>>= 1;
        }
        return res;
    }
}
~~~

时间复杂度 O(log2 n)： 此算法循环内部仅有 移位、与、加 等基本运算，占用 O(1) ；逐位判断需循环 log2 n 次，其中 log2 n 代表数字 n 最高位 1 的所在位数（例如 log2 4 = 2, log2 16 = 4）。
空间复杂度 O(1) ： 变量 res 使用常数大小额外空间。



### 解 2：巧用 n \& (n - 1)

- (n−1) 解析： 二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。
- n \& (n - 1) 解析： 二进制数字 n 最右边的 1 变成 0 ，其余不变。

算法流程：

- 初始化数量统计变量 res 。
- 循环消去最右边的 1 ：当 n = 0 时跳出。
  - res += 1 ： 统计变量加 1 ；
  - n &= n - 1 ： 消去数字 n 最右边的 1 。

- 返回统计数量 res 。

~~~java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int res = 0;
        while (n!=0) {
            res ++;
            n &= (n-1);
        }
        return res;
    }
}
~~~

- 时间复杂度 O(M) ： n \& (n - 1) 操作仅有减法和与运算，占用 O(1) ；设 M 为二进制数字 n 中 1 的个数，则需循环 M 次（每轮消去一个 1 ），占用 O(M) 。
- 空间复杂度 O(1) ： 变量 res 使用常数大小额外空间。

