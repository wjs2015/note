# #[剑指 Offer 64. 求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)

求 `1+2+...+n` ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 

## 示例 1：

```
输入: n = 3
输出: 6
```

## 示例 2：

```
输入: n = 9
输出: 45
```

## 限制：

- `1 <= n <= 10000`

## 解题思路：

### 解 1：递归

可以容易想到：

~~~java
class Solution {
    public int sumNums(int n) {
        n += n==0 ? 0 : sumNums(n-1);
        return n;
    }
}
~~~

但不可使用三目运算符，于是可以使用逻辑运算符&&或||的短路性质。以&&为例，为了使n=0时停止递归，应在&&的条件1处设置一个当n=0即为false的条件，这样条件2中的语句就不会执行。反之当n!=0时，条件1为true，条件2处的语句会被执行，因此递归语句应放在条件2中。

~~~java
class Solution {
    public int sumNums(int n) {
        boolean flag = n != 0 && (n += sumNums(n-1)) > 0;
        // boolean flag = n == 0 || (n += sumNums(n-1)) > 0;

        return n;
    }
}
~~~

- 时间复杂度：O(N)
- 空间复杂度：O(N)



### 解 2：快速乘

考虑 A 和 B 两数相乘的时候我们如何利用加法和位运算来模拟，其实就是将 B 二进制展开，如果 B 的二进制表示下第 i 位为 1，那么这一位对最后结果的贡献就是 A*(1<<i)，即 A<<i。我们遍历 B 二进制展开下的每一位，将所有贡献累加起来就是最后的答案，这个方法也被称作「俄罗斯农民乘法。

回到本题，由等差数列求和公式我们可以知道 1+2+⋯+n 等价于 n(n+1)/2 ，对于除以 2 我们可以用右移操作符来模拟，那么等式变成了 n(n+1)>>1，剩下不符合题目要求的部分即为 n(n+1)，根据上文提及的快速乘，我们可以将两个数相乘用加法和位运算来模拟，但是可以看到上面的 C++ 实现里我们还是需要循环语句，有没有办法去掉这个循环语句呢？答案是有的，那就是自己手动展开，因为题目数据范围 n 为 [1,10000]，所以 n 二进制展开最多不会超过 14 位，我们手动展开 14 层代替循环即可。

~~~java
class Solution {
    public int sumNums(int n) {
        int A = n, B = n+1;
        boolean flag;
        int ans = 0;

        flag = (B & 1) > 0 && (ans += A) > 0;//B的末位为1，才证明该位有贡献
        B >>= 1;//逐位遍历B
        A <<= 1;//与B的末位贡献对应

        flag = (B & 1) > 0 && (ans += A) > 0;
        B >>= 1;
        A <<= 1;
        
        flag = (B & 1) > 0 && (ans += A) > 0;
        B >>= 1;
        A <<= 1;
        
        flag = (B & 1) > 0 && (ans += A) > 0;
        B >>= 1;
        A <<= 1;
        
        flag = (B & 1) > 0 && (ans += A) > 0;
        B >>= 1;
        A <<= 1;
        
        flag = (B & 1) > 0 && (ans += A) > 0;
        B >>= 1;
        A <<= 1;
        
        flag = (B & 1) > 0 && (ans += A) > 0;
        B >>= 1;
        A <<= 1;
        
        flag = (B & 1) > 0 && (ans += A) > 0;
        B >>= 1;
        A <<= 1;
        
        flag = (B & 1) > 0 && (ans += A) > 0;
        B >>= 1;
        A <<= 1;
        
        flag = (B & 1) > 0 && (ans += A) > 0;
        B >>= 1;
        A <<= 1;
        
        flag = (B & 1) > 0 && (ans += A) > 0;
        B >>= 1;
        A <<= 1;
        
        flag = (B & 1) > 0 && (ans += A) > 0;
        B >>= 1;
        A <<= 1;
        
        flag = (B & 1) > 0 && (ans += A) > 0;
        B >>= 1;
        A <<= 1;
        
        flag = (B & 1) > 0 && (ans += A) > 0;
        B >>= 1;
        A <<= 1;

        return ans >> 1;//除以2

    }
}
~~~

- 时间复杂度：O(logn)，二进制表示共logn位。
- 空间复杂度：O(1)

