# #[771. 宝石与石头](https://leetcode-cn.com/problems/jewels-and-stones/)

 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。

J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此"a"和"A"是不同类型的石头。

## 示例 1:

输入: J = "aA", S = "aAAbbbb"
输出: 3

## 示例 2:

输入: J = "z", S = "ZZ"
输出: 0

## 注意:

- S 和 J 最多含有50个字母
-  J 中的字符不重复。

### 解题思路：

### 解 1： 暴力法

```java
class Solution {
        public int numJewelsInStones(String J, String S) {
            int ans = 0;
            for (char s: S.toCharArray()) // For each stone...
                for (char j: J.toCharArray()) // For each jewel...
                    if (j == s) {  // If the stone is a jewel...
                        ans++;
                        break; // Stop searching whether this stone 's' is a jewel
                    }
            return ans;
        }
}
```

时间复杂度：O(J.length * S.length))

空间复杂度：在 Python 实现中，空间复杂度为 O(1)O(1)。在 Java 实现中，空间复杂度为 O(J.length * S.length))

### 解 2：哈希集合

```java
class Solution {
    public int numJewelsInStones(String J, String S) {
    ​    Set<Character> Jset = new HashSet();
    ​    for (char j: J.toCharArray())
    ​    Jset.add(j);
    ​    int ans = 0;
    ​    for (char s: S.toCharArray())
    ​        if (Jset.contains(s))
    ​            ans++;
    ​    return ans;
    }
}
```

时间复杂度：O(J.length + S.length))。O(J.length}) 这部分来自于创建 J，O(S.length)这部分来自于搜索 S

空间复杂度：O(J.length)

### 解 3：遍历字符串判断每一个元素即可：

```java
class Solution {
  public int numJewelsInStones(String J, String S) {
    ​    int out = 0;
    ​    for (int i = 0; i < S.length(); i++) {
    ​      if (J.indexOf(S.charAt(i)) >= 0) {
    ​        out++;
    ​      }
    ​    }
    ​    return out;
    }
}


```

