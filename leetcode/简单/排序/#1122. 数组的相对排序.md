# #[1122. 数组的相对排序](https://leetcode-cn.com/problems/relative-sort-array/)

给你两个数组，arr1 和 arr2，

- arr2 中的元素各不相同
- arr2 中的每个元素都出现在 arr1 中

对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。 

## 示例：

输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
输出：[2,2,2,1,4,3,3,9,6,7,19]

## 提示：

- arr1.length, arr2.length <= 1000
- 0 <= arr1[i], arr2[i] <= 1000
- arr2 中的元素 arr2[i] 各不相同
- arr2 中的每个元素 arr2[i] 都出现在 arr1 中

## 解题思路：桶排序

### 解 1：因为限制了元素大小小于1000，因此可以使用数组完成：

~~~java
class Solution {
    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        int[] bucket = new int[1001];
        int[] out = new int[arr1.length];

        for (int i : arr1) {
            bucket[i]++;
        }
        int index = 0;
        for(int i : arr2) {
            while(bucket[i] != 0) {
                out[index] = i;
                index++;
                bucket[i]--;
            }
        }
        for (int i=0; i <bucket.length; i++) {
            if (bucket[i] != 0) {
                for(int j = 0; j < bucket[i]; j++) {
                    out[index] = i;
                    index++;
                }
            }
        }
        return out;
    }
}
~~~

### 解 2：若是没有限制元素大小，应该使用Map数据结构，为了使数据有序，使用TreeMap：

~~~java
class Solution {
    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        TreeMap<Integer, Integer> map = new TreeMap<>();
        int[] out = new int[arr1.length];
        int index = 0;
        for (int i : arr1) {
            if (map.containsKey(i)) {map.replace(i, map.get(i)+1);}
            else {map.put(i, 1);}
        }
        for (int i : arr2) {
            int fre = map.remove(i);
            for(int j = 0; j < fre; j++) {
                out[index] = i;
                index++;
            }
        }
        while (map.size() != 0) {
            int temp = map.firstKey();
            int fre = map.remove(temp);
            for(int j = 0; j < fre; j++) {
                out[index] = temp;
                index++;
            }
        }
        return out;
    }
}
~~~

